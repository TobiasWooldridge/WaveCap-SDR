"""Type stubs for SoapySDR Python bindings.

This provides type information for the SoapySDR library which does not
have native type hints. Based on SoapySDR API version 0.8.
"""
from typing import Any, Dict, Iterator, List, Optional, Sequence, Tuple, Union

# Direction constants
SOAPY_SDR_TX: int
SOAPY_SDR_RX: int

# Stream format constants
SOAPY_SDR_CF32: str  # Complex float32
SOAPY_SDR_CF64: str  # Complex float64
SOAPY_SDR_CS32: str  # Complex int32
SOAPY_SDR_CS16: str  # Complex int16
SOAPY_SDR_CS12: str  # Complex int12
SOAPY_SDR_CS8: str   # Complex int8
SOAPY_SDR_CU8: str   # Complex uint8
SOAPY_SDR_CU16: str  # Complex uint16
SOAPY_SDR_CU32: str  # Complex uint32

# Stream flags
SOAPY_SDR_HAS_TIME: int
SOAPY_SDR_END_BURST: int
SOAPY_SDR_END_ABRUPT: int
SOAPY_SDR_ONE_PACKET: int
SOAPY_SDR_MORE_FRAGMENTS: int
SOAPY_SDR_WAIT_TRIGGER: int

# ArgInfo types
class ArgInfo:
    """Device/stream argument info."""
    key: str
    value: str
    name: str
    description: str
    units: str
    type: str
    range: "Range"
    options: List[str]
    optionNames: List[str]


class Range:
    """Numeric range with min/max/step."""
    def __init__(self, minimum: float = 0.0, maximum: float = 0.0, step: float = 0.0) -> None: ...
    def minimum(self) -> float: ...
    def maximum(self) -> float: ...
    def step(self) -> float: ...


class StreamResult:
    """Result from readStream/writeStream operations."""
    ret: int  # Number of samples or error code
    flags: int
    timeNs: int


class Stream:
    """Opaque stream handle."""
    pass


class Device:
    """SoapySDR Device interface for controlling SDR hardware."""

    def __init__(self, args: Union[str, Dict[str, str]] = "") -> None:
        """Create a device from device args string or dict."""
        ...

    # Static methods for device discovery
    @staticmethod
    def enumerate(args: str = "") -> List["SoapySDRKwargs"]: ...

    @staticmethod
    def make(args: Union[str, Dict[str, str]] = "") -> "Device": ...

    @staticmethod
    def unmake(device: Optional["Device"] = None) -> None: ...

    # Identification
    def getDriverKey(self) -> str: ...
    def getHardwareKey(self) -> str: ...
    def getHardwareInfo(self) -> Dict[str, str]: ...

    # Channels
    def getNumChannels(self, direction: int) -> int: ...
    def getChannelInfo(self, direction: int, channel: int) -> Dict[str, str]: ...
    def getFullDuplex(self, direction: int, channel: int) -> bool: ...

    # Stream API
    def getStreamFormats(self, direction: int, channel: int) -> List[str]: ...
    def getNativeStreamFormat(self, direction: int, channel: int) -> Tuple[str, float]: ...
    def getStreamArgsInfo(self, direction: int, channel: int) -> List[ArgInfo]: ...

    def setupStream(
        self,
        direction: int,
        format: str,
        channels: Sequence[int] = (0,),
        args: Union[str, Dict[str, str]] = ""
    ) -> Stream: ...

    def closeStream(self, stream: Stream) -> None: ...
    def getStreamMTU(self, stream: Stream) -> int: ...
    def activateStream(
        self,
        stream: Stream,
        flags: int = 0,
        timeNs: int = 0,
        numElems: int = 0
    ) -> int: ...
    def deactivateStream(self, stream: Stream, flags: int = 0, timeNs: int = 0) -> int: ...

    def readStream(
        self,
        stream: Stream,
        buffs: Sequence[Any],
        numElems: int,
        flags: int = 0,
        timeoutUs: int = 100000
    ) -> Union[StreamResult, Tuple[int, int, int, int]]: ...

    def writeStream(
        self,
        stream: Stream,
        buffs: Sequence[Any],
        numElems: int,
        flags: int = 0,
        timeNs: int = 0,
        timeoutUs: int = 100000
    ) -> Union[StreamResult, Tuple[int, int, int]]: ...

    def getNumDirectAccessBuffers(self, stream: Stream) -> int: ...

    # Antenna API
    def listAntennas(self, direction: int, channel: int) -> List[str]: ...
    def setAntenna(self, direction: int, channel: int, name: str) -> None: ...
    def getAntenna(self, direction: int, channel: int) -> str: ...

    # DC offset correction
    def hasDCOffsetMode(self, direction: int, channel: int) -> bool: ...
    def setDCOffsetMode(self, direction: int, channel: int, automatic: bool) -> None: ...
    def getDCOffsetMode(self, direction: int, channel: int) -> bool: ...
    def hasDCOffset(self, direction: int, channel: int) -> bool: ...
    def setDCOffset(self, direction: int, channel: int, offset: complex) -> None: ...
    def getDCOffset(self, direction: int, channel: int) -> complex: ...

    # IQ balance correction
    def hasIQBalanceMode(self, direction: int, channel: int) -> bool: ...
    def setIQBalanceMode(self, direction: int, channel: int, automatic: bool) -> None: ...
    def getIQBalanceMode(self, direction: int, channel: int) -> bool: ...
    def hasIQBalance(self, direction: int, channel: int) -> bool: ...
    def setIQBalance(self, direction: int, channel: int, balance: complex) -> None: ...
    def getIQBalance(self, direction: int, channel: int) -> complex: ...

    # Gain API
    def listGains(self, direction: int, channel: int) -> List[str]: ...
    def hasGainMode(self, direction: int, channel: int) -> bool: ...
    def setGainMode(self, direction: int, channel: int, automatic: bool) -> None: ...
    def getGainMode(self, direction: int, channel: int) -> bool: ...

    def setGain(self, direction: int, channel: int, value_or_name: Union[float, str], value: Optional[float] = None) -> None: ...
    def getGain(self, direction: int, channel: int, name: str = "") -> float: ...
    def getGainRange(self, direction: int, channel: int, name: str = "") -> Range: ...

    # Frequency API
    def setFrequency(
        self,
        direction: int,
        channel: int,
        frequency: float,
        args: Union[str, Dict[str, str]] = ""
    ) -> None: ...

    def getFrequency(self, direction: int, channel: int, name: str = "") -> float: ...
    def listFrequencies(self, direction: int, channel: int) -> List[str]: ...
    def getFrequencyRange(self, direction: int, channel: int, name: str = "") -> List[Range]: ...
    def getFrequencyArgsInfo(self, direction: int, channel: int) -> List[ArgInfo]: ...
    def getFrequencyCorrection(self, direction: int, channel: int) -> float: ...
    def setFrequencyCorrection(self, direction: int, channel: int, value: float) -> None: ...

    # Sample Rate API
    def listSampleRates(self, direction: int, channel: int) -> List[float]: ...
    def setSampleRate(self, direction: int, channel: int, rate: float) -> None: ...
    def getSampleRate(self, direction: int, channel: int) -> float: ...
    def getSampleRateRange(self, direction: int, channel: int) -> List[Range]: ...

    # Bandwidth API
    def listBandwidths(self, direction: int, channel: int) -> List[float]: ...
    def setBandwidth(self, direction: int, channel: int, bw: float) -> None: ...
    def getBandwidth(self, direction: int, channel: int) -> float: ...
    def getBandwidthRange(self, direction: int, channel: int) -> List[Range]: ...

    # Clocking API
    def listClockSources(self) -> List[str]: ...
    def setClockSource(self, source: str) -> None: ...
    def getClockSource(self) -> str: ...
    def listTimeSources(self) -> List[str]: ...
    def setTimeSource(self, source: str) -> None: ...
    def getTimeSource(self) -> str: ...

    # Sensor API
    def listSensors(self, direction: int = -1, channel: int = 0) -> List[str]: ...
    def getSensorInfo(self, name: str, direction: int = -1, channel: int = 0) -> ArgInfo: ...
    def readSensor(self, name: str, direction: int = -1, channel: int = 0) -> str: ...

    # Register API (for advanced low-level access)
    def listRegisterInterfaces(self) -> List[str]: ...
    def writeRegister(self, name: str, addr: int, value: int) -> None: ...
    def readRegister(self, name: str, addr: int) -> int: ...

    # Settings API
    def getSettingInfo(self, direction: int = -1, channel: int = 0) -> List[ArgInfo]: ...
    def writeSetting(self, key: str, value: str) -> None: ...
    def readSetting(self, key: str) -> str: ...

    # GPIO API
    def listGPIOBanks(self) -> List[str]: ...
    def writeGPIO(self, bank: str, value: int) -> None: ...
    def readGPIO(self, bank: str) -> int: ...


class SoapySDRKwargs:
    """Device arguments dictionary returned from enumerate().

    Acts like a dict but may have special methods for iteration.
    Common keys: driver, label, serial, index, tuner, etc.
    """
    def keys(self) -> List[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: str) -> str: ...
    def __iter__(self) -> Iterator[str]: ...


# Module-level device factory function (alternative to Device.make)
def make_device(args: Union[str, Dict[str, str]] = "") -> Device: ...
